You're right - let me strip this down to **actionable queries only**, using your actual working pattern and focusing on `flightDetailId`.

## Ultra-Focused Actionable Queries

### 1. **Critical Failures Only - Ready for Alert**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.event" as event nodrop
| json field=_raw "event" as event2 nodrop
| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop
| json field=_raw "message.equipmentId" as equipment_id nodrop
| json field=_raw "equipmentId" as equipment_id2 nodrop

| if(isBlank(event), event2, event) as event
| if(isBlank(msg), msg2, msg) as msg
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id
| if(isBlank(equipment_id), equipment_id2, equipment_id) as equipment_id

// Only actual failures - no debug noise
| where tolowercase(msg) matches "*error*" 
    or tolowercase(msg) matches "*fail*"
    or tolowercase(event) matches "*error*"
    or tolowercase(event) matches "*fail*"

// Critical: SAP/GeoMart failures mean ingestion dead
| where tolowercase(msg) matches "*sap*" 
    or tolowercase(msg) matches "*geomart*"
    or tolowercase(event) matches "*sap*"
    or tolowercase(event) matches "*geomart*"

| fields flight_detail_id, equipment_id, event, msg
| count by flight_detail_id
```

**Purpose**: These flights are **dead** - they need manual intervention

---

### 2. **Status Counts - The 3 Numbers Business Wants**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop

| if(isBlank(msg), msg2, msg) as msg
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id

// Only care about inspection status changes
| where !isBlank(msg) and tolowercase(msg) matches "*insert asset inspection*"

// Extract status from the message
| parse regex field=msg "status[:\s]+['\"]?(?<status>\w+)" nodrop

| where !isBlank(status) 
| where tolowercase(status) in ("invalid", "ingesting", "inspection_queue")

| count_distinct(flight_detail_id) by status
```

**Purpose**: 
- **Invalid** = permanently broken, needs manual fix
- **Ingesting** = stuck, Lambda should move to inspection_queue
- **inspection_queue** = success

---

### 3. **Batch Health - Which Flights Have Incomplete Images**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop

| if(isBlank(msg), msg2, msg) as msg
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id

// Look for batch completion messages
| where tolowercase(msg) matches "*completed batch image processing*"
    or tolowercase(msg) matches "*all images processed*"

// Extract success count vs total
| parse regex field=msg "(?<success>\d+)\s*(?:out of|of|/)\s*(?<total>\d+)" nodrop
| parse regex field=msg "(?<pct>\d+)\s*%" nodrop

// Flag incomplete batches
| where (!isBlank(pct) and num(pct) < 100)
    or (!isBlank(success) and !isBlank(total) and num(success) < num(total))

| fields flight_detail_id, success, total, pct, msg
| count by flight_detail_id
```

**Purpose**: Less than 100% = invalid status = business needs to know

---

### 4. **What's Actually Failing Right Now - Error Breakdown**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop
| json field=_raw "message.equipmentId" as equipment_id nodrop
| json field=_raw "equipmentId" as equipment_id2 nodrop

| if(isBlank(msg), msg2, msg) as msg
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id
| if(isBlank(equipment_id), equipment_id2, equipment_id) as equipment_id

// Only errors
| where tolowercase(msg) matches "*error*" or tolowercase(msg) matches "*fail*"

// Categorize - focus on what team can ACT on
| if(tolowercase(msg) matches "*sap*", "SAP Down/Invalid", 
     if(tolowercase(msg) matches "*geomart*", "GeoMart Down/Invalid",
        if(tolowercase(msg) matches "*s3*", "S3 Access Issue",
           if(tolowercase(msg) matches "*inspection*", "DB Insert Failed",
              if(isBlank(equipment_id), "No Equipment ID (SAP)", 
                 "Other"))))) as error_type

| where error_type != "Other"

| count by error_type, flight_detail_id
| count by error_type
```

**Purpose**: Shows WHERE the pipeline is breaking - actionable for ops

---

### 5. **Image Processor Success Check**

```sumo
_sourceCategory = */image-processor*

| json field=_raw "transactionId" as txn_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id nodrop
| json field=_raw "message" as msg nodrop

| where !isBlank(txn_id) and !isBlank(flight_detail_id)

// Look for batch completion
| where tolowercase(msg) matches "*image processing batch*"

// Determine if failed
| if(tolowercase(msg) matches "*failure*" or tolowercase(msg) matches "*error*", 
     "FAILED", "SUCCESS") as outcome

| count by txn_id, flight_detail_id, outcome
| transpose row txn_id, flight_detail_id column outcome

// Only show problems
| where num(FAILED) > 0 or isBlank(SUCCESS)

| fields txn_id, flight_detail_id, FAILED, SUCCESS
```

**Purpose**: Transaction failed = images stuck in DLQ = needs reprocessing

---

### 6. **SAP/GeoMart Call Success Rate (Time Series)**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main
| timeslice 15m

| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop
| json field=_raw "message.event" as event nodrop
| json field=_raw "event" as event2 nodrop

| if(isBlank(msg), msg2, msg) as msg
| if(isBlank(event), event2, event) as event

// Only SAP/GeoMart operations
| where tolowercase(concat(msg, event)) matches "*sap*" 
    or tolowercase(concat(msg, event)) matches "*geomart*"

// Determine service and outcome
| if(tolowercase(concat(msg, event)) matches "*sap*", "SAP", "GeoMart") as service
| if(tolowercase(msg) matches "*success*" or tolowercase(msg) matches "*completed*", 
     "success", "failure") as outcome

| count by _timeslice, service, outcome
| transpose row _timeslice column service, outcome
```

**Purpose**: Spike in failures = alert ops immediately

---

### 7. **Equipment ID Missing - Instant Invalid**

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.equipmentId" as equipment_id nodrop
| json field=_raw "equipmentId" as equipment_id2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop
| json field=_raw "message.msg" as msg nodrop
| json field=_raw "msg" as msg2 nodrop

| if(isBlank(equipment_id), equipment_id2, equipment_id) as equipment_id
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id
| if(isBlank(msg), msg2, msg) as msg

// Filter for inspection creation events
| where tolowercase(msg) matches "*inspection*" 
    or tolowercase(msg) matches "*sap*"

// Missing equipment ID = SAP failed = ingestion invalid
| where isBlank(equipment_id)

| fields flight_detail_id, msg
| count by flight_detail_id
```

**Purpose**: No equipment_id from SAP = flight will be marked invalid

---

## Dashboard Layout (3 Panels, That's It)

### **Panel 1: Status Overview (Single Value Panels)**
- Query 2
- **3 separate number widgets**: Invalid | Ingesting | Inspection Queue

### **Panel 2: Active Failures (Table)**
- Query 4
- Shows what's breaking right now with counts
- **Alert trigger**: Any count > 0 for SAP/GeoMart

### **Panel 3: SAP/GeoMart Health (Line Chart)**
- Query 6
- Visual spike detection
- **Alert trigger**: Failure rate > 5% in 15min window

---

## Alerts to Set Up

```sumo
// Alert 1: SAP/GeoMart Down
Query 1 with: | where count > 5

// Alert 2: Stuck in Ingesting
Query 2 with: | where status = "ingesting" and count > 10

// Alert 3: Missing Equipment IDs
Query 7 with: | where count > 0
```

This is **minimal, actionable, business-focused**. No fluff about log levels or request IDs - just "is it working or not?"


Ah, I see the issue! Looking at your log structure:

```json
{
  "batchStats": {
    "totalFiles": 18,
    "inspections": 18,
    "successfullyProcessed": 18,
    "invalid": 0,
    "skipped": 0,
    "failedFiles": []
  },
  "imagesReadyForLambda": 18,
  "successStatus": "100 batch image processing - all images processed successfully"
}
```

The percentage isn't a separate field - it's **embedded in the `successStatus` string**. And the actual counts are in the `batchStats` object.

## Corrected Batch Health Query

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.batchStats.totalFiles" as total_files nodrop
| json field=_raw "batchStats.totalFiles" as total_files2 nodrop
| json field=_raw "message.batchStats.successfullyProcessed" as success_count nodrop
| json field=_raw "batchStats.successfullyProcessed" as success_count2 nodrop
| json field=_raw "message.batchStats.invalid" as invalid_count nodrop
| json field=_raw "batchStats.invalid" as invalid_count2 nodrop
| json field=_raw "message.successStatus" as success_status nodrop
| json field=_raw "successStatus" as success_status2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop

| if(isBlank(total_files), total_files2, total_files) as total_files
| if(isBlank(success_count), success_count2, success_count) as success_count
| if(isBlank(invalid_count), invalid_count2, invalid_count) as invalid_count
| if(isBlank(success_status), success_status2, success_status) as success_status
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id

// Only events with batch stats
| where !isBlank(total_files)

// Calculate success percentage
| (num(success_count) / num(total_files)) * 100 as success_pct

// Flag incomplete batches (< 100% = invalid status)
| where success_pct < 100 or num(invalid_count) > 0

| fields flight_detail_id, total_files, success_count, invalid_count, success_pct, success_status
```

## Even Simpler - Just Flag Invalid Batches

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.batchStats" as batch_stats nodrop
| json field=_raw "batchStats" as batch_stats2 nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop
| json field=_raw "flightDetailId" as flight_detail_id2 nodrop

| if(isBlank(batch_stats), batch_stats2, batch_stats) as batch_stats
| if(isBlank(flight_detail_id), flight_detail_id2, flight_detail_id) as flight_detail_id

// Parse the nested JSON
| json field=batch_stats "totalFiles" as total nodrop
| json field=batch_stats "successfullyProcessed" as success nodrop
| json field=batch_stats "invalid" as invalid nodrop

// Only show problems
| where !isBlank(total) and (num(success) < num(total) or num(invalid) > 0)

| fields flight_detail_id, total, success, invalid
| count by flight_detail_id
```

## What This Actually Shows You

- **success_count < total_files** → Some images failed → Status will be `invalid`
- **invalid_count > 0** → Explicit failures → Status will be `invalid`
- **success_count = total_files AND invalid_count = 0** → 100% success → Status will be `ingesting` (then Lambda moves to `inspection_queue`)

This directly maps to what Ibrahim explained: "If 14 out of 15 successful, status = invalid. If 15 out of 15, status = ingesting."

Want me to refine this further based on other fields you're seeing in the logs?

You're absolutely right - I'm being inefficient and potentially filtering out logs. Let me fix this properly:

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

| json field=_raw "message.batchStats.totalFiles" as total nodrop
| json field=_raw "message.batchStats.successfullyProcessed" as success nodrop
| json field=_raw "message.batchStats.invalid" as invalid nodrop
| json field=_raw "message.flightDetailId" as flight_detail_id nodrop

// Fallback to root level if message wrapper doesn't exist
| if(isBlank(total), json field=_raw "batchStats.totalFiles", total) as total nodrop
| if(isBlank(success), json field=_raw "batchStats.successfullyProcessed", success) as success nodrop
| if(isBlank(invalid), json field=_raw "batchStats.invalid", invalid) as invalid nodrop
| if(isBlank(flight_detail_id), json field=_raw "flightDetailId", flight_detail_id) as flight_detail_id nodrop

// Only show logs that have batch stats AND have problems
| where !isBlank(total) and (num(success) < num(total) or num(invalid) > 0)

| fields flight_detail_id, total, success, invalid
```

Wait, that's still convoluted. Let me do this the **clean way**:

```sumo
_sourceCategory = OA/Sumo-Sherlock/*/be-ingestion-main

// Extract from both possible locations in one go
| parse regex field=_raw "\"totalFiles\":\s*(?<total>\d+)" nodrop
| parse regex field=_raw "\"successfullyProcessed\":\s*(?<success>\d+)" nodrop
| parse regex field=_raw "\"invalid\":\s*(?<invalid>\d+)" nodrop
| parse regex field=_raw "\"flightDetailId\":\s*(?:\")?(?<flight_detail_id>[^,\"\}]+)" nodrop

// Only show logs with batch stats that have problems
| where !isBlank(total) and (num(success) < num(total) or num(invalid) > 0)

| fields flight_detail_id, total, success, invalid
| count by flight_detail_id
```

This uses regex parsing which **doesn't care about the JSON structure** - it just finds the values wherever they are in the raw log. No filtering, no double extraction, just get the data.

Is this closer to what you want?
